{"name":"Space Invaders","tagline":"A Project for Advanced Programming","body":"# Space Invaders\r\n\r\n![Screenshot](https://raw2.github.com/rubenvanassche/Space-Invaders/master/docs/screenshot.png?token=619804__eyJzY29wZSI6IlJhd0Jsb2I6cnViZW52YW5hc3NjaGUvU3BhY2UtSW52YWRlcnMvbWFzdGVyL2RvY3Mvc2NyZWVuc2hvdC5wbmciLCJleHBpcmVzIjoxMzkwMjMzMDc5fQ%3D%3D--0a63b7da3c9e7b677a9972b143caeb3d01a006c8)\r\n\r\n## Introduction\r\nWelcome, to the Space Invaders project, in this docuemnt you find information about how to compile and run the application. Dependencies are SFML and off course a c++ complier+ linker.\r\n\r\nThe document describes what each class in the system represents, after that I explain my design choises.\r\n\r\nThe API is documented and can be found in the docs/html directory, open the index.html file and start reading.\r\n\r\n## Functionality\r\n- Aliens, Guns, Walls\r\n- Basic Space Invaders gameplay\r\n- Levels\r\n\r\n## Binaries\r\nAt this moment there are only binaries for OS X. Linux users can download and compile the source.\r\n[Download for OS X](https://github.com/rubenvanassche/Space-Invaders/releases/download/1.0/Space.Invaders.OS.X.zip)\r\n\r\n## Compiling\r\n\tcmake .\r\n\tmake\r\n\tmake install\r\n\r\n## Running\r\nAfter compiling:\r\n\t./SpaceInvaders\r\n\r\n## Generating The Documentation\r\nChange the following line in the CMakeLists.txt file at the root directory from:\r\n\r\n\t# Documentation\r\n\tSET(BUILD_DOCS FALSE)\r\n\r\nTo:\r\n\r\n\t# Documentation\r\n\tSET(BUILD_DOCS TRUE)\r\n\r\n## The System\r\n### Some Names\r\n- Controllers : work between views and entities\r\n- Models : set's of entities\r\n- Entities : specific objects, storing information and having a interface for querying information\r\n- Views : objects connected to entities representing them to the user\r\n- Factories : systems to create Entities and views\r\n- SI(Space Invaders Element) :  special container containing all the models, views and controllers which is being used through the whole system\r\n- Libraries : classes for building all above\r\n\r\n### Libraries\r\n**Assets**\r\nA library which can hold textures and fonts so those can be loaded when needed and don't waste memory with endless copies of them.\r\n\r\n**Controller**\r\nThe base class for a Controller.\r\n\r\n**Entity**\r\nThe base class for an Entity.\r\n\r\n**Factory**\r\nThe base class for a Factory.\r\n\r\n**ScreenEntity**\r\nThe base class for a ScreenEntity, an Entity which will be presented on screen and has special functions for that(location, move, collision detection, ...)\r\n\r\n**SI**\r\nThe Space Invaders Element\r\n\r\n**Size**\r\nA class for representing a size with an width, height and point. Beter said : a box in 2D space.\r\n\r\n**Utilities**\r\nFile with the util namespace with some useful utilities for the whole system.\r\n\r\n**View**\r\nThe base class for a View.\r\n\r\n### Controllers\r\nEach of the following controllers inherits the base controller and define some actions in the system.\r\n\r\n**Collision Controller**\r\nHas only one function check() which is called each time after an update of all the elements(Aliens, Walls, Guns, ...) in the game. It will check if certain elements collide with each other and if so it will call the appropriate controller for handeling the collision.\r\n\r\n**Event Controller**\r\nThe event controller is called each time an event(keyboard touch) happens, it will determine what to do after the event. This means selection the right controller and function.\r\n\r\n**Game Controller**\r\nCan be seen as the \"main\" controller, when the game is started the first controller to be called is the game controller. It has functions to build up the game(initiate all the elements), show the startscreen and the game over or game won screen. And of course it shows the screen where the game is played and gives all the events to the appropriate controllers.\r\n\r\n**Motion Controller**\r\nThe motion controller is the controller who moves the elements over the screen. Sometimes these elements are moved automatic, for example the aliens they will be moved each time a certain time passes by in the Game Controller. Sometimes elements are moved by the user, for example the gun is getting moved when the event controller gets an left or right keyboard touch. The Game controller will receive the event and give it to the Event controller who decides to call the Motion controller to move the gun. Besides moving elements has the motion controller also the functions to shoot bullets. These are also automatic as manual by the user called.\r\n\r\n**Screen Controller**\r\nThe screen controller handles the screen(window) provided. During one cycle of the game each view will be able to draw to the window. But these views won't be showed until the screen controller's redraw method is called from somewhere. It also handles the function to close the window.\r\n\r\n### Entities\r\n\r\n**Alien(ScreenEntity)**\r\nRepresents the data from an alien, it looks just like an ScreenEntity from where it is inherited but has also a ticktock function which can be called by the view to show the appropriate image of the alien.\r\n\r\n**Bullet(ScreenEntity)**\r\nThe bullet Entity represents an bullet on the screen, it knows from where it was fired and has also a special overloaded kill function which will find his view and remove it as soon as the bullet is killed. So we don't fill up our memory with unnecessary things.\r\n\r\n**Game**\r\nThe only entity which is not an screen entity holds information about the game such as the height and width of the game and the current level playing.\r\n\r\n**Gun(ScreenEntity)**\r\nIs almost the same as it's base Screen Entity class but needs to handle sometimes different so some functions are overloaded. It represents of course the player's gun.\r\n\r\n**Wall(ScreenEntity)**\r\nProbably the most boring Entity, it is just a ScreenEntity and nothing more.\r\n\r\n### Factories\r\nThis needs no extra information, factories are created for Aliens, Bullets, Guns and Walls. They will create a Entity and place it in the model container. After that a view is created and stored in the view container. The Entity and View get linked to each other for futher information exchange and our new element is created.\r\n\r\n### Views\r\nEach element(Aliens, Walls, Bullets, Guns) has it's own view. In this view the corresponding entity will be queried for information like the postion and width and height of the element. The appropriate texture for the element will be asked from the assets library and then the element will be drawn on the screen. If the assets library throws an exception because the image of the element can not be found, then the view will generate a geometric shape so the game can still be played.\r\n\r\nBesides these elements views there are some other views:\r\n\r\n**Game Ended View**\r\nWill be shown to the user when he won or lose the game. No images over here but fonts, when those fonts couldn't be found it will print the information to the console.\r\n\r\n**Info View**\r\nYet another view linked to an Screen Entity, this little text in the left corner of the screen during playing will show the user's score and remaining lives.\r\n\r\n**Start Screen View**\r\nThe first view the user get's to see when he starts the game, he can select a level and start the game.\r\n\r\n## Design\r\n\r\n### Space Invaders Element\r\nIs being used in the whole system, some examples:\r\n\r\n- Factories: each Factory stores it's new created views and entities automatically in the right containers, SI provides these containers.\r\n- Gun Entity: needs to know the width of the window, so the gun doesn't go off the screen. The SI element gives it access to the game Entity which stores the game width. Also when the gun moves, the Gun Entity will update the position of the gun and immediately ask the screen controller to redraw the screen.\r\n- Event Controller: will at each event(keyboard touch) redirect to the appropriate function in the Game Controller using the SI element.\r\n- Game Controller: can ask simply information about the game(mostly the current level) and also get the amount of lives the gun(player) has to see if the game is over. Also this information can be provided wit the SI element.\r\n- The Motion Controller: works on large sets stored in SI, like the aliens.\r\n\r\nThrough the system there can be found dozens of examples why SI is very useful, but some remarks over here:\r\n\r\n**Hiding**\r\n\r\nThe SI element doesn't provide hiding (yet). So let's say a controller isn't allowed to update the screen, it will be possible through the SI element. Off course this can be controlled by a privileges system in SI. So that each time the SI element is called the caller should ask for privileges and the SI element can decide to give them, but that's for a further version.\r\n\r\n**Why do views not have access to the SI element?**\r\n\r\nViews just need to know something about their connected Entity, nothing more.\r\n\r\n**Why the SI element?**\r\n\r\n- It reduces the amount of parameters to be given in the constructor\r\n- In the whole system there is only one SI element, this limits the amount of stupid errors being made\r\n- It makes the code readable, for example to redraw the window the only thing todo id : this->si->controller->screen->redraw();\r\n- You have everything you need everywhere \r\n- Adding new functionality to the system is much easier by using si\r\n\r\n### MVC\r\nThough there are multiple interpretations of the MVC system mine work a little bit different then the most. Instead of defining the model as a class with entities in and defining functions in that class to work on these entities I just used a list with entities and defined it as model.\r\n\r\n**Why?**\r\n\r\nThe default interpretation is great for the aliens, you can move them just by calling one function in the controller to the model and say move. The model will then decide how each alien should move but that's in my opinion not the function of the model, there is a controller for that. The model should store data and not work on data.\r\n\r\nSo the motion controller moves the aliens in my design, it calls on each alien Entity the move function. This move function accepts only 4 values : UP, DOWN, LEFT, RIGHT so the Entity can decide how much he has to move. \r\nThis can come in handy when you want some Aliens to move faster then others. The computation is done by the controller and the only thing the entity should do is change it's position.\r\n\r\n### Observer Pattern\r\nAlso here I do it a little bit different, the observer pattern should be used to call the function to redraw the window with all the new elements on it. I haven't implemented a special observer class with notifiers.\r\n\r\n**Why?**\r\n\r\nOne word SI(Space Invaders Element), this element is available through all controllers and Entities. So when some controller or entity decides the screen should be updated, it can call in the SI element the screen controller where the window redraw function is defined. Actually this looks like the observer pattern but it isn't exactly it. \r\n\r\n### Factory Pattern\r\nIn the description of the project it was said we needed to use an abstract factory pattern, I used just a factory pattern.\r\n\r\n**Why?**\r\n\r\nI think an abstract factory pattern is too complex for this project, it will require a lot of classes and make the code more complex then it should be. The factory pattern has the same function as the abstract factory pattern but is much nicer. It has been used to create the different aliens(they have the same speed but a different name and image, raising the speed is just one line of code) and guns. Also each Gun and Alien have a Bullet Factory inside them to provide them at all time with bullets.\r\n\r\n### Inheritance and polymorphism\r\n\r\nThe whole system rests on inheritance: each controller, factory, view, entity inherits from a base library(class). Now I have to admit these libraries doesn't look so spectacular. A better example is the ScreenEntity it inherits from the Entity and the Gun, Alien, Wall and bullet entities inherit from it.\r\n\r\nThe ScreenEntity declares some special functions for entities besides the base entity class. The children of this class sometimes just use these function but it get's more interesting when they get overloaded.\r\nA few examples:\r\n\r\n- Move: this function is overloaded in Alien Entity, when the Alien is moved it will also update the ticktock which represents if the alien view should show an image of an open or closed alien. Also the gun has a modified move function which will stop moving the gun when it reaches the borders of the screen.\r\n- Kill: this function is overloaded in the bullet Entity, when a bullet is killed it's appropriate view will be searched so it can be removed from the memory.\r\n\r\nAnother example is the view library, this one defines a virtual draw function. Each view is overloading this function with it's own code. This makes it possible to draw a gun with rectangles and triangles provided by SFML. Th aliens will be drawn by provided images. Though all views work the same way, they are all called within the screen controller's redraw function by using the draw function from teh view.\r\n\r\n### Exception Handling\r\nIs build into the assets class and views so when an asset(texture, font) is not available a simple representation is shown.\r\n\r\n### Extending the system\r\nA design is good if it is easy to add functionality without too much effort. Let's have a look at some examples:\r\n\r\n**How difficult is it to add a new type of Alien**\r\n\r\nLet's go wild and we want a completely new alien that travels once from left to right on the screen:\r\n\r\n- Create a new view which represents the Alien.\r\n- Create a new function in the Alien factory which creates our new alien, give it a special name by using the setName function, and change the speed. Of course we use our new view.\r\n- Change the move Aliens function in the motion controller to move this type of alien only left or right.\r\n- Add an AlienFactory to the Game Controller's startgame function and let it create our new alien at random moments.\r\n\r\nThat's it! Now our new alien can be killed and so add points to our gun, it can move, it can shoot bullets. Average time to build this? Maybe one hour.\r\n\r\n**How difficult is it to add a multiplayer mode?**\r\n\r\n- Add a new gun in the game build up process, this is just one line of code.\r\n- Add to the movegun function in the motion controller an index to specify the gun, 6 lines of code.\r\n- Add to the event controller the events for moving our second gun, 6 lines of code.\r\n- Check in the startgame function in game controller if one of the controllers is dead instead of one, 4 lines of code.\r\n- Add in the build up process a infoView connected to the second gun to show it's lives and score, 3 lines of code.\r\n\r\nTotal 20 lines of code, looks quite good. Some things maybe need to be changed like the explanation for the users in the startview what the controls are for the two guns(at this moment it describes only the controls for one gun), but with this 20 lines a working multiplayer option can be implemented.\r\n\r\n**How difficult is it to add a wall that moves?**\r\n\r\n- Add a move function to motion controller, 10 lines of code.\r\n- Call this function in the gamecontroller when the aliens move, 1 line of code.\r\n\r\nNo more to do.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}